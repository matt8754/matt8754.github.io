<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Greenwave | By Matt Jia</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="greenwave.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" id="step1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="gating-on-automated-tests-in-fedora-greenwave">Gating on automated tests in Fedora - Greenwave</h1><p>Factory 2.0</p><p>Matt Jia &lt;<a href="mailto:mjia@redhat.com">mjia@redhat.com</a>&gt;</p><div class="notes"><p>Good morning, everyone. Thank you for coming to my talk. Over the next 30 mins,
you are going to hear about something that will change the way you are doing
package updates in Fedora. Do not be scared,  we are not going to make your life harder, :-).
For those of you do not know me, my name is Matt Jia. I&#x2019;m working in Factory 2.0 team at RedHat.</p></div></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="automated-test-results-in-bodhi">Automated test results in Bodhi</h1><img src="images/test-results.png" width="800px" height="600px"></img><div class="notes"><p>The fedora QA has done a great job, running lots of automated tests when you file a new update</p><p>As shown in this picture, there are some test results of a package update for glibc.</p><p>Currently, we store these test results in ResultsDB.</p><p>How many of you have seen the test results in ResultsDB before? Do you know what ResultsDB is and what ResultsDB
does? To refresh your memory, ResultsDB is a simple service for recording the automated test results generated by
many different testing systems. When we say testing systems, we are talking about systems like
taskotron, CI pipeline, OpenQA and many other testing systems in Fedora.</p><p>As you can see, we have got many passing test results here which is good. However,
we also have got some failing test results.</p><p>So do you actually really care about these failing etst results? I think the answer is we do care.
What can we do with these automated test results? Can we use them to help us enforce quality on
package updates in fedora ? Let's find out. Today, I&#x2019;m going to introduce two services that we&#x2019;re working on.
The first one is called Greenwave, the other one is called WaiverDB.</p></div></div><div class="step step-level-1" step="2" id="greenwave" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="greenwave-is">Greenwave is:</h1><ul><li>a service for making decisions</li><li>about artifacts</li><li>at certain gating points</li><li>based on test results in ResultsDB</li><li>according to some policies</li></ul><img src="images/Greenwave.gif"></img><div class="notes"><p>So let's get started with Greenwave. Originally, it is known as Policy Engine.
It's recently renamed to Greenwave because we want to make it clear that
Greenwave is not driving any of the processes, and it is not storing and applying any
arbitrary policies about anything.</p><p>The fact is Greenwave is actually a service for making <em>business</em> decisions
or answering yes/no questions. It is about artifacts, such as RPMs, modules,containers.
It can be used at various gating and automation points in our pipeline. When we say gating points,
we&#x2019;re talking about Bodhi or errata tool. The decisions are made based on test results in
ResultsDB according to some policies.</p><p>Those policies are about what checks need to pass before an artifact is considered good enough.</p><p>So why do we need Greenwave? What problems can Greenwve help us to solve in Bodhi&#xFF1F;
Right now there are two problems we have identified in Bodhi.</p></div></div><div class="step step-level-1" step="3" id="problem1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="problem-1">Problem #1</h1><p>No checks are required for distro-wide packages</p><img src="images/quality-risk.jpg" width="800px" height="600px"></img><div class="notes"><p>The first one is we don&#x2019;t enforce any checks for distro-wide packages in Bodhi.
What that means if you want, you can release your package update regardless of any
failed test results. However, if there is a test failed indicating the package update
is broken, you could end up breaking other people's packages which is not what
you are expecting.</p><p>To solve this problem, we as fedora community want to enforce certain checks for
all the distro-wide packages. We want to gate package updates based on the test
results in Bodhi when an update is going to be released. So the goal here is to
prevent the broken changes that would affect other packages as well as improve
package quality.</p></div></div><div class="step step-level-1" step="4" data-y="1000" id="checks" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-z="0"><h1 id="what-checks-do-we-want-to-enforce">What checks do we want to enforce?</h1><ul><li>dist.abicheck</li><li>dist.rpmdeplint</li><li>dist.upgradepath</li></ul><div class="notes"><p>Here is a list of checks that we would like to enforce. Dist.apicheck, dist.rpmdeplint,
and dist.upgradepath. Basically, Tasktoron is running these checks for each package update.
These checks are considered extremely important by the distributions. These failures on
a package update will almost certainly break applications or libraries that depend on the
update. These failures should be inspected carefully by the package maintainer.
or the fedora QA.  So having these checks could help us find the problems
earlier in our release pipeline.. We believe enforcing these three checks should
form a good basis for us and we can expand to add more checks as needed in the future.</p><p>So In Greenwave, these checks could be expressed as a set of rules in a policy
for different products.</p></div></div><div class="step step-level-1" step="5" data-x="5600" data-scale="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-y="2000" data-z="0"><h1 id="problem-2">Problem #2</h1><p>Specifying required checks is a repetitive manual process</p><img src="images/repetitive-manual.jpg" width="800px" height="600px"></img><div class="notes"><p>The second problem is Bodhi actually has a feature to allow you to specify
required tests at the moment. However, it is a manual process as you have to file
your checks in every update. Obviously, this repetitive process is not
a big fun. Greenwave can automate this process by allowing users to define policies
about what checks need to pass before a package update is considered as &#x201C;good enough&#x201D;.</p><p>As a consequence, Greenwave will automatically apply those policies when making decisions.</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="3000" data-z="0"><h1 id="why-a-new-service">Why a new service?</h1><div class="notes"><p>So Why do we need a new service? why not define policies in Bodhi itself? Bodhi sounds like
a perfect place for defining policies as it is already a gating system that fedora packagers are used to.</p><p>The reason is nowadays Bodhi is not the only place we want to introduce gating based on test results
. We would like to reuse the same logic to perform gating as much as possible,
so other gating points do not need to reinvent the wheel.</p><p>This will make our life easier to maintain it in one place rather than many places.</p><p>That is why it does make sense to put Greenwave into a microservice along with the other
microservices that we have developed in Factory 2 project.</p></div></div><div class="step step-level-1" step="7" id="badtest" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4000" data-y="4000" data-z="0"><h1 id="what-happens-when-a-test-goes-bad">What happens when a test goes bad?</h1><img src="images/false-postive.jpg" width="800px" height="600px"></img><div class="notes"><p>In terms of the failing required tests, what happens when a test goes bad?
In a real life, you do not want to hear words like that from a doctor ,right?</p><p>If a test failed, it could be because of infrastructure problems or other known issues,
you probably want to waive it. Since the results in ResultsDB are immutable and can not be
changed by humans, we need to have a new service WaiverDB to allow us to override the
failing test results.</p></div></div><div class="step step-level-1" step="8" data-x="3500" data-scale="1" id="waiverdb" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-y="5000" data-z="0"><h1 id="waiverdb-is">WaiverDB is:</h1><ul><li>a microservice for storing waivers against test results in ResultsDB</li><li>generalizing the existing waiving functionalities</li></ul><div class="notes"><p>In a short summary, WaiverDB is a simple micronservice to record waivers against
failing test results in ResultsDB, so generalize the waiving functionalities we
already have in some of the testing tools like rpmdiff, TPS. Just the same as
ResutlsDB, WaiverDB is a central place where all the waivers are stored.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3000" data-y="6000" data-z="0"><img src="images/workflow.jpg" width="800px" height="600px"></img><div class="notes"><p>To put things all together, when a package update is going to be released in Bodhi.
Bodhi will ask Greenwave to make a decision to decide whether the package updated
is okay to go. And then Greenwave will query both ResultsDB and WaiverDB
to make the decision based on those test results and waivers.</p></div></div><div class="step step-level-1" step="10" id="freshmaker" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="2500" data-y="7000" data-z="0"><h1 id="help-freshmaker-enforce-quality">Help Freshmaker enforce quality</h1><p>Gating on the <em>rebuilds</em></p><div class="notes"><p>Freshmaker is a service for automatically rebuilding artifacts when their dependencies get updated.</p><p>For example, when you update a spec file in your RPM package, Freshmaker will automatically
trigger the rebuild of all the modules and  containers that depending on that RPM. It will save you
a lot of time and effort to rebuild all of them by yourself, which is really nice!</p><p>At the moment, Freshmaker is unconditionally trigger the rebuilds all the time,
but in some situations, the rebuilds are not necessarily needed. For example,
if an underlying artifact is released but did not pass certain checks, freshmaker
should not trigger the rebuilds of all the upstream artefacts. Instead, it should
wait until he underlying artifact got fixed first.</p><p>So to make Freshmaker more efficient as well as enforce quality, Greenwave can be
used here to gate the rebuilds based on the test results.</p><p>We&#x2019;re considering two approaches for Freshmaker to use Greenwave at the moment.</p><p>One is when an artifact is released, we can use Greenwave to decide whether Freshmaker
should use this artifact to rebuild the upstream artifacts.</p><p>The other one is when a set of rebuilds are complete, Greenwave can be used to decide
whether to release them. It isn&#x2019;t clear which approach we will take though.</p></div></div><div class="step step-level-1" step="11" id="underhood" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="2000" data-y="8000" data-z="0"><h1 id="how-greenwave-works-under-the-hood">How Greenwave works under the hood</h1><div class="notes"><p>So the next topic is I would like talk about how Greenwave works under the hood
and where are we at today with the current implementation.</p></div></div><div class="step step-level-1" step="12" id="policyexample" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1500" data-y="9000" data-z="0"><h1 id="an-example-of-a-greenwave-policy">An example of a Greenwave policy</h1><pre class="highlight code YAML"><span class="nn">---</span> <span class="kt">!Policy</span>
<span class="l-Scalar-Plain">id</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">1</span>
<span class="l-Scalar-Plain">product_version</span><span class="p-Indicator">:</span>
  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">fedora-26</span>
<span class="l-Scalar-Plain">decision_context</span><span class="p-Indicator">:</span>
  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">bodhi_update_push_stable</span>
<span class="l-Scalar-Plain">rules</span><span class="p-Indicator">:</span>
  <span class="p-Indicator">-</span> <span class="kt">!PassingTestCaseRule</span> <span class="p-Indicator">{</span><span class="nv">test_case_name</span><span class="p-Indicator">:</span> <span class="nv">dist.abicheck</span><span class="p-Indicator">}</span>
  <span class="p-Indicator">-</span> <span class="kt">!PassingTestCaseRule</span> <span class="p-Indicator">{</span><span class="nv">test_case_name</span><span class="p-Indicator">:</span> <span class="nv">dist.deplint</span><span class="p-Indicator">}</span>
  <span class="p-Indicator">-</span> <span class="kt">!PassingTestCaseRule</span> <span class="p-Indicator">{</span><span class="nv">test_case_name</span><span class="p-Indicator">:</span> <span class="nv">dist.upgradepath</span><span class="p-Indicator">}</span></pre><div class="notes"><p>First, let&#x2019;s talk about how to define a policy because it plays such an important role in Greenwave.</p><p>Here is an example policy which I made up for Bodhi. As you can see, each policy has id,
product version, decision context and rules.  Id is no more than an unique identifier,
product version are the PDC identifiers. decision context is a label named through
coordination between policy author and consuming tools. A list of rules is about what tests are
required to be passing. You can also leave empty rules here if you want to no enforce
any checks for certain products.
In reality, Bodhi could use a policy like this to gate the package updates during the release process.
Ideally, a policy can be applied globally, per product version,
or per package. So far, we only support a policy per product version.</p><p>With the current implementation, policies are expressed in YAML configuration files deployed with the
application and this may most likely change in the future because ultimately we want the policies
enforced by Greenwave to be "self-service".</p></div></div><div class="step step-level-1" step="13" id="gapiexample" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1000" data-y="10000" data-z="0"><h1 id="an-example-of-calling-greenwave-api">An example of calling Greenwave API</h1><pre class="highlight code">$ http POST http://greenwave.stg.fedoraproject.org/api/v1.0/decision \
      decision_context=bodhi_update_push_stable \
      product_version=fedora-26 \
      subject:='[{"item":"glibc-1.0-1.f26", "type": "koji_build"}]'</pre><pre class="highlight code JSON"><span class="p">{</span>
    <span class="nt">"applicable_policies"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="nt">"policies_satisified"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="nt">"summary"</span><span class="p">:</span> <span class="s2">"1 of 3 required tests failed"</span><span class="p">,</span>
    <span class="nt">"unsatisfied_requirements"</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">"item"</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">"item"</span><span class="p">:</span> <span class="s2">"glibc-1.0-1.f26"</span><span class="p">,</span>
                <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"koji_build"</span>
            <span class="p">},</span>
            <span class="nt">"testcase"</span><span class="p">:</span> <span class="s2">"dist.abicheck"</span><span class="p">,</span>
            <span class="nt">"type"</span><span class="p">:</span> <span class="s2">"test-result-failed"</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span></pre><div class="notes"><p>Now let&#x2019;s imagine that we are going to push a package update to stable for glibc
in Bodhi and we have got one failed test result of the check required by the
policy I mentioned before.
.</p><p>If we ask Greenwave for a decision, it gonna tell us the policy is not satisfied yet because
we got a failing test result. At the current stage, Greenwave only has a public
API to make decisions, we may add more APIs in the future. To call the API,
you need to pass those POST request parameters: decision context, product version and subject.</p><p>We have talked about decision context and product version before. subject is a list of
dicts, where each one contains the necessary key-values used by Greenwave to
look up the test results from ResultsDB.</p><p>As you can see in the response of this example, Greenwave gives back a decision that a policy
is not satisfied yet because we have got one test failing which is dist.apicheck.</p></div></div><div class="step step-level-1" step="14" id="wapiexample" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="500" data-y="11000" data-z="0"><h1 id="an-example-of-calling-waiverdb-api">An example of calling WaiverDB API</h1><pre class="highlight code">$ http --auth-type=negotiate --auth : POST \
     http://waiverdb.stg.fedoraproject.org/api/v1.0/waivers/ \
     result_id=1 \
     product_version=fedora-26 \
     waived=true \
     comment="Because I say it!"</pre><pre class="highlight code JSON"><span class="p">{</span>
    <span class="nt">"comment"</span><span class="p">:</span> <span class="s2">"Because I say it!"</span><span class="p">,</span>
    <span class="nt">"id"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">"product_version"</span><span class="p">:</span> <span class="s2">"fedora-26"</span><span class="p">,</span>
    <span class="nt">"result_id"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="nt">"timestamp"</span><span class="p">:</span> <span class="s2">"2017-08-16T22:21:29.926900"</span><span class="p">,</span>
    <span class="nt">"username"</span><span class="p">:</span> <span class="s2">"mjia"</span><span class="p">,</span>
    <span class="nt">"waived"</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span></pre><div class="notes"><p>If you think the failing test is false-postive and want to move your update forward.
You can create a waiver by calling WaiverDB API to waive the failing test result with
a good reason. So other people can know who and why this failing test result was waived.
To call the API, you need to have the result id, product version and a good reason.</p><p>Having said that, we are not expecting people to call this API directly in Bodhi.
We're picturing that people will be able to waive the failing test result
from the Bodhi Web UI. But, this is still something we are not quite sure yet.</p></div></div><div class="step step-level-1" step="15" id="nextsteps" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="12000" data-z="0"><h1 id="next-steps">Next steps</h1><ul><li>Bodhi integration</li><li>Message bus driven</li><li>Expand policies to cover more products</li></ul><div class="notes"><p>In terms of the future. we're looking at Bodhi integration at the moment.
In short words, Bodhi will use Greenwave to gate package updates based on the test
results. As far as I know, it is almost complete and under testing.</p><p>Next one is message bus driven. We would like to use fedmsg to automatically drive all
the processes.</p><p>Basically, Greenwave will listen on message bus for new resultsdb and waiverdb events.
For each event, it will determine if any decision contexts change from pass to fail or fail
to pass that causes the decision to change, it will publish a message to message bus about
the newly satisfied/unsatisfied policy, so tools like Bodhi can consume this sort
of message to decide whether to move the update forward.</p><p>Lastly, we want to expand policies as many as possible to cover more products.
This will help Greenwave quickly evolve and give us more confidence in our
design.</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="120" data-scale="1" data-x="-500" data-y="13000" data-z="0"><h1 id="questions"><em>Questions?</em></h1><div class="notes"><p>Okay, that&#x2019;s really I want to present today.  Thank you all. Any questions?</p></div></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>