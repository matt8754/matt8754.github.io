:title: Greenwave | By Matt Jia
:data-transition-duration: 1500
:css: greenwave.css


----

:id: step1

Gating on automated tests in Fedora - Greenwave
===============================================

Factory 2.0

Matt Jia <mjia@redhat.com>

.. note::

  Good morning, everyone. Thank you for coming to my talk. Over the next 30 mins,
  you are going to hear about something that will change the way you are doing
  package updates in Fedora. Do not be scared,  we are not going to make your life harder, :-).
  For those of you do not know me, my name is Matt Jia. I’m working in Factory 2.0 team at RedHat.

----

Automated test results in Bodhi
===============================

.. image:: images/test-results.png
    :height: 600px
    :width: 800px

.. note::

  The fedora QA has done a great job, running lots of automated tests when you file a new update

  This is a screenshot of the Automated Test Tab on the webui in Bodhi where it shows the test
  results from ResultsDB.

  As shown in this picture, there are some test results of a package update for glibc.

  How many of you have seen the test results in ResultsDB before? Do you know what ResultsDB is and what ResultsDB
  does? To refresh your memory, ResultsDB is a simple service for recording the automated test results generated by
  many different testing systems. When we say testing systems, we are talking about systems like
  taskotron, CI pipeline, OpenQA and many other testing systems in Fedora.

  As you can see, we have got many passing test results here which is good. However,
  we also have got some failing test results.

  So do you actually really care about these failing etst results? I think the answer is we do care.
  What can we do with these automated test results? Can we use them to help us enforce quality on
  package updates in fedora ? Let's find out. Today, I’m going to introduce two services that we’re working on.
  The first one is called Greenwave, the other one is called WaiverDB.

----

:id: greenwave

Greenwave is:
===============

* a service for making decisions
* about artifacts
* at certain gating points
* based on test results in ResultsDB
* according to some policies

.. image:: images/Greenwave.gif

.. note::

  So let's get started with Greenwave. Originally, it is known as Policy Engine.
  It's recently renamed to Greenwave because we want to make it clear that
  Greenwave is not driving any of the processes, and it is not storing and applying any
  arbitrary policies about anything.

  The fact is Greenwave is actually a service for making *business* decisions
  or answering yes/no questions. It is about artifacts, such as RPMs, modules,containers.
  It can be used at various gating and automation points in our pipeline. When we say gating points,
  we’re talking about Bodhi or internal tools like errata tool. The decisions are made based on test
  results in ResultsDB according to some policies.

  Those policies are about what checks need to pass before an artifact is considered good enough.

  So why do we need Greenwave? What problems can Greenwve help us to solve in Bodhi？
  Right now there are two problems we have identified in Bodhi.

----

:id: problem1

Problem #1
==========

No checks are required for distro-wide.

.. image:: images/quality-risk.jpg
    :height: 600px
    :width: 800px

.. note::

  The first one is we don’t enforce any checks across all the packages in Bodhi.
  What that means if you want, you can release your package update regardless of any
  failed test results. However, if there is a test failed indicating your package update
  is broken, you could end up breaking other people's packages which is not what
  you are expecting.

  To solve this problem, we as fedora community want to enforce certain checks across
  all the distributions. We want to gate package updates based on the test
  results in Bodhi when an update is going to be released. So the goal here is to
  prevent the broken changes that would affect other packages as well as improve
  package quality.

----

:data-y: r1000
:id: checks

What checks do we want to enforce?
==================================

* dist.abicheck
* dist.rpmdeplint
* dist.upgradepath

.. note::

  Here is a list of checks that we would like to enforce. Dist.apicheck, dist.rpmdeplint,
  and dist.upgradepath. Basically, Tasktoron is running these checks for each package update.
  These checks are considered extremely important by the distributions. These failures on
  a package update will almost certainly break applications or libraries that depend on the
  update. These failures should be inspected carefully by the package maintainer.
  or the fedora QA.  So having these checks could help us find the problems
  earlier in our release pipeline. We believe enforcing these three checks should
  form a good basis for us and we can expand to add more checks as needed in the future.

  So In Greenwave, these checks could be expressed as a set of rules in a policy
  for different products.

----

:data-x: r-800
:data-scale: 1

Problem #2
==========

Specifying required checks is a repetitive manual process

.. image:: images/repetitive-manual.jpg
    :height: 600px
    :width: 800px

.. note::

  The second problem is Bodhi actually has a feature to allow you to specify
  required tests at the moment. However, it is a manual process as you have to file
  your checks in every update. Obviously, this repetitive process is not
  a big fun. Greenwave can automate this process by allowing packagers to define policies
  about what checks need to pass before a package update is considered as “good enough”.

  As a consequence, Greenwave will automatically apply those policies when making decisions.

----

Why a new service?
==================


.. note::

  So Why do we need a new service? why not define policies in Bodhi itself? Bodhi sounds like
  a perfect place for defining policies as it is already a gating system that fedora packagers are used to.

  The reason is nowadays Bodhi is not the only place we want to introduce gating based on test results
  . We would like to reuse the same logic to perform gating as much as possible,
  so other gating points do not need to reinvent the wheel.

  This will make our life easier to maintain it in one place rather than many places.

  That is why it does make sense to put Greenwave into a microservice along with the other
  microservices that we have developed in Factory 2 project.

----

:id: badtest

What happens when a test goes bad?
==================================

.. image:: images/broken-machine.jpg
    :height: 600px
    :width: 600px

.. note::

  In terms of the failing required tests, what happens when a test goes bad?
  In a real life, you do not want to hear words like that from a doctor ,right?

  If a test failed, it could be because of infrastructure problems or other known issues,
  you probably want to waive it. Since the results in ResultsDB are immutable and can not be
  changed by humans, we need to have a new service WaiverDB to allow us to override the
  failing test results.

----

:data-x: r-500
:data-scale: 1


:id: waiverdb

WaiverDB is:
============

* a microservice for storing waivers against test results in ResultsDB
* generalizing the existing waiving functionalities

.. note::

  In a short summary, WaiverDB is a simple micronservice to record waivers against
  failing test results in ResultsDB, so generalize the waiving functionalities we
  already have in some of the testing tools like rpmgrill, internal tools like rpmdiff,
  TPS. Just the same as ResutlsDB, WaiverDB is a central place where all the waivers are
  stored.

----

.. image:: images/workflow.png
    :height: 600px
    :width: 800px

.. note::

  To put things all together, when a package update is going to be released in Bodhi.
  Bodhi will ask Greenwave to make a decision to decide whether the package update
  is okay to go. And then Greenwave will query both ResultsDB and WaiverDB
  to get the test results and waivers and make the decision based on them.

----

:id: freshmaker

Help Freshmaker enforce quality
===============================

Gating on the *rebuilds*

.. note::

  Freshmaker is a service for automatically rebuilding artifacts when their dependencies get updated.

  For example, when you update a spec file in your RPM package, Freshmaker will automatically
  trigger the rebuild of all the modules and  containers that contain that RPM package. It will save you
  a lot of time and effort to rebuild all of them by yourself, which is really nice!

  At the moment, Freshmaker is unconditionally trigger the rebuilds all the time,
  but in some situations, the rebuilds are not necessarily needed. For example,
  if an underlying artifact is released but did not pass certain checks which may be
  a sign that this underlying artifact is broken, freshmaker should not trigger the
  rebuilds of all the upstream artefacts. Instead, it should wait until the underlying artifact
  got fixed first.

  So to make Freshmaker more efficient as well as enforce quality, Greenwave can be
  used here to gate the rebuilds based on the test results.

  We’re considering two approaches for Freshmaker to use Greenwave at the moment.

  One is when an artifact is released, we can use Greenwave to decide whether Freshmaker
  should use this artifact to rebuild the upstream artifacts.

  The other one is when a set of rebuilds are complete, Greenwave can be used to decide
  whether to release them. It isn’t clear which approach we will take though.


----

:id: underhood

How Greenwave works under the hood
==================================

.. note::

  So the next topic is I would like talk about how Greenwave works under the hood
  and where are we at today with the current implementation. All of these three
  services are implemented by using Flask which is a microframework for Python.
  It is well documented and easy to code.


----

:id: policyexample

An example of a Greenwave policy
================================

.. code:: YAML

  --- !Policy
  id: 1
  product_version:
    - fedora-26
  decision_context:
    - bodhi_update_push_stable
  rules:
    - !PassingTestCaseRule {test_case_name: dist.abicheck}
    - !PassingTestCaseRule {test_case_name: dist.deplint}
    - !PassingTestCaseRule {test_case_name: dist.upgradepath}

.. note::

  First, let’s talk about how to define a policy because it plays such an important role in Greenwave.
  A policy is a place where packagers could specify extra checks.

  Here is an example policy which I made up for Bodhi. As you can see, each policy has id,
  product version, decision context and rules.  Id is no more than an unique identifier,
  product version are the PDC identifiers. decision context is a label named through
  coordination between policy author and consuming tools. A list of rules is about what tests are
  required to be passing. You can also leave empty rules here if you want to no enforce
  any checks for certain products.
  In reality, Bodhi could use a policy like this to gate the package updates during the release process.
  Ideally, a policy can be applied globally, per product version,
  or per package. So far, we only support a policy per product version.

  With the current implementation, policies are expressed in YAML configuration files deployed with the
  application and this may most likely change in the future because ultimately we want the policies
  enforced by Greenwave to be "self-service".

----

:id: gapiexample

An example of calling Greenwave API
===================================

.. code::

    $ http POST http://greenwave.stg.fedoraproject.org/api/v1.0/decision \
          decision_context=bodhi_update_push_stable \
          product_version=fedora-26 \
          subject:='[{"item":"glibc-1.0-1.f26", "type": "koji_build"}]'


.. code:: JSON

    {
        "applicable_policies": [1],
        "policies_satisified": false,
        "summary": "1 of 3 required tests failed",
        "unsatisfied_requirements": [
            {
                "item": {
                    "item": "glibc-1.0-1.f26",
                    "type": "koji_build"
                },
                "testcase": "dist.abicheck",
                "type": "test-result-failed"
            }
        ]
    }

.. note::

  Now let’s imagine that we are going to push a package update to stable for glibc
  in Bodhi and we have got one failed test result of the check required by the
  policy I mentioned before.
  .

  If we ask Greenwave for a decision, it gonna tell us the policy is not satisfied yet because
  we got a failing test result. At the current stage, Greenwave only has a public
  API to make decisions, we may add more APIs in the future. To call the API,
  you need to pass those POST request parameters: decision context, product version and subject.

  We have talked about decision context and product version before. subject is a list of
  dicts, where each one contains the necessary key-values used by Greenwave to
  look up the test results from ResultsDB.

  As you can see in the response of this example, Greenwave gives back a decision that a policy
  is not satisfied yet because we have got one test failing which is dist.apicheck.

----

:id: wapiexample

An example of calling WaiverDB API
==================================

.. code::

    $ http --auth-type=negotiate --auth : POST \
         http://waiverdb.stg.fedoraproject.org/api/v1.0/waivers/ \
         result_id=1 \
         product_version=fedora-26 \
         waived=true \
         comment="Because I say it!"

.. code:: JSON

    {
        "comment": "Because I say it!",
        "id": 1,
        "product_version": "fedora-26",
        "result_id": 1,
        "timestamp": "2017-08-16T22:21:29.926900",
        "username": "mjia",
        "waived": true
    }

.. note::

  If you think the failing test is false-postive and want to move your update forward.
  You can create a waiver by calling WaiverDB API to waive the failing test result with
  a good reason. So other people can know who and why this failing test result was waived.
  To call the API, you need to have the result id, product version and a good reason.

  Having said that, we are not expecting people to call this API directly in Bodhi.
  We're picturing that people will be able to waive the failing test result
  from the Bodhi Web UI. But, this is still something we are not quite sure yet.

----

:id: nextsteps

Next steps
==========

* Bodhi integration
* Message bus driven
* Expand policies to cover more products

.. note::

  In terms of the future. we're looking at Bodhi integration at the moment.
  In short words, Bodhi will use Greenwave to gate package updates based on the test
  results. As far as I know, the code is pretty much done and we are looking forward
  to enabling it on production.

  Next one is message bus driven. We would like to use fedmsg to automatically drive all
  the processes.

  Basically, Greenwave will listen on message bus for new resultsdb and waiverdb events.
  For each event, it will determine if any decision contexts change from pass to fail or fail
  to pass that causes the decision to change, it will publish a message to message bus about
  the newly satisfied/unsatisfied policy, so tools like Bodhi can consume this sort
  of message to decide whether to move the update forward.

  Lastly, we want to expand policies as many as possible to cover more products.
  This will help Greenwave quickly evolve and give us more confidence in our
  design.

----

:data-rotate: 120
:id: examples

*Questions?*
============

* https://pagure.io/greenwave

* https://pagure.io/waiverdb

.. note::

  Okay, that’s really I want to present today.  Thank you all. Any questions?
